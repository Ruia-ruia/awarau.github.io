---
layout: post
title: Linux kernel Use-After-Free (CVE-2021-23134) exploitation.
use_math: true
---

## The bug
The bug is a Use After Free (UAF) in the Near-Field-Communication (NFC) subsystem of the Linux kernel (before v5.12.4).

Let $S_i$ be a socket constructed with:

`socket(AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP)`

Then suppose we bind $S_i$ to an address $A$.
$S_i$ will be loaded with a pointer to an object $L$ of type: `nfc_llcp_local`
However, if the bind fails for $S_i$ then $L$ will be freed while $S_i \to L$ remains defined. So a future computation which dereferences $S_i \to L$ will transition the kernel into a weird state.

The patch removes the pointer $S_i \to L$ when $L$ is freed on bind failure.
https://www.openwall.com/lists/oss-security/2021/05/11/4

## Exploitation
### Assumptions
sysctl knob `vm.unprivileged_userfaultfd=1`
and capability `CAP_NET_RAW` by default or through user namespaces.

### Strategy overview
The strategy is to leak and overwrite an object $R$ of type `io_ring_ctx`. By doing this, we can control the `sq_creds` field of $R$. Note that $R$’s type is chosen because objects of $R$’s and $L$’s types are similarly issued from kmalloc-2k.

$R \to$ `sq_creds` replaces the current credentials of the submission queue poller (SQP) thread when it performs an io_uring request. If `sq_creds` points to a `struct cred` object $C$ such that $C$ has uid, gid, and so on set to $0$, then the SQP thread will perform I/O requests as if the invoking user were root.

We can therefore read or write files on disk as an unprivileged user by issuing requests to the io_uring instance (managed by our controlled $R$). The demonstration here just reads out /etc/shadow. But to attain root privileges, simply edit /etc/passwd to enter a root shell.

### Components
We use the following components and techniques:

1. three NFC sockets: $S_1$, $S_2$, and $S_3$.
2. six threads: main, $X$, $Y$, $Z$, $T$, and $H$. 
3. `msgsnd` + `msgrcv` for leaking $R$. 
4. `userfaultfd` + `setxattr` for writing to $R$ and for ensuring that $R$ is not reallocated by another thread during and after exploitation.

### Background and conventions
With three NFC sockets, we are able to free $L$ three times. However, after each free, we need to overwrite some portion of $L$, which we call the local header, to ensure that the subsequent free will not cause a crash. Specifically, we write to set the refcount to $1$ so that the next free will not set the refcount to $-1$, raising a warning or crashing the process. Additionally, we ensure the first `list_head` field of $L$ is well defined.

With threads $X$, $Y$, $Z$ we coordinate: allocating $L$ again, holding $L$ in memory, reading from $L$ and writing to $L$. After a certain point, $L$ is denoted by $R$ as we reallocate the same object which was once used for $S_i \to L$ as $R$. The aim is to show that $L \equiv R$ through our exploit logic.

The `setxattr` technique is well known. It allows the user to allocate a `kvalue` object whose size the user determines. It allows us to write to the beginning of an object. However, after we finish writing to `kvalue` from userspace, `kvalue` is freed. 

The `msgsnd` + `msgrcv` technique is also known. As a recap: `msgsnd` allocates a `msg_msg` object which acts as a header followed by a message text whose length the user determines. The `msg_msg` object fields should remain well defined if we want `msgrcv` to work correctly. On the other hand, `msgrcv` copies out the message text to userspace and then frees the `msg_msg` object. The user determines the length of the message text as well as when the `msg_msg` is received and freed. 

We use `userfaultfd` to pause a thread while in the kernel context via `setxattr`. This technique is documented here: https://duasynt.com/blog/linux-kernel-heap-spray. We use two variants of the technique. One issues a page fault when reading at a userspace address. The other issues a page fault when writing at a userspace address. These correspond to `copy_from_user` and `copy_to_user`, respectively. The former is associated with `setxattr` and the latter with `msgrcv`. 

Finally, a note on conventions. In the next section “unblocking thread $X$” usually means handling the page fault caused by thread $X$ while in the kernel context. A thread cannot handle its own page fault, but delegates this to a thread further up in the hierarchy. Though, not necessarily the next one up i.e. thread $Z$ unblocks thread main and thread $Y$ while thread $Y$ unblocks thread $X$. 

If we are dealing with a `setxattr` page fault, then to “handle the page fault” means we provide a new buffer to the `userfaultfd` subsystem with an ioctl. This then allows the write to `kvalue` ($L$) to continue, afterwards freeing `kvalue` ($L$). Similarly, with the `msgrcv` page fault we unprotect the buffer and continue reading. The reader is advised to look over Vitaly Nikolenko’s explanation linked above. This will explain what we mean when we say “page fault at a certain offset” in the next section.

### Method description
First, we close S1, freeing L. We then allocate 3 msgsnd buffers which discard additional allocations. Now that L is free, we can reallocate it using setxattr. The value which we pass to setxattr is memory protected such that reading at a certain offset will result in a page fault. With userfaultfd we register the corresponding range so that thread X can catch the page fault. The offset is the size of our own defined header for L’s type. We need to overwrite the header of L so that freeing it again (when we close S2) will not result in an early crash. This header just includes a list_head and a refcount field, whose counter value we set to 1.

Second, from thread X, we catch the page fault issued in setxattr from the main thread. Now we do the same as in the main thread with the difference: we register a new range for a new value, we want the thread Y to catch the next page fault, and the offset at which the page fault occurs is the size of struct msg_msg + 8. We still overwrite L with our header.

Third, from thread Y, we catch the previous page fault issued in setxattr as performed by X. 
However, this time after we close S3, freeing L for the third time, we allocate L again through msgsnd. We then create a write protected buffer and register it with userfaultfd, our userspace receiver msg_msg sits at a negative offset from the write protected buffer. We pass the address of our msg_msg object to msgrcv. When msgrcv, specifically store_msg writes to an offset from msg_msg, another page fault will be issued. This offset is determined by the size of the msg_msg header. 

At this point, main is paused to hold L in place. We later unblock main by handling the page fault issued from setxattr in main - this will free L to be reallocated as R. Y is paused to hold L in place. Y’s continuation would leak the data in L (or at that point, R) to userspace, and then Y would continue thread X by resolving the setxattr page fault issued from X. X is paused and will continue writing to L (R) when Y resolves its page fault.

Fourth, from thread Z, we catch the page fault issued in msgrcv as performed by Y.  
Now we unblock main by handling the page fault caught by X. This continues the setxattr write over L and subsequently frees L for the fourth time. We then allocate an io_ring_ctx object and so L becomes R. Finally, Z attempts to acquire a lock which, if successful, would lead it to create a new thread T allocating R again with setxattr. However, at this point, thread Y holds the lock and so Z is paused attempting to acquire it.

The three major phases of this exploit begin here. 

Fifth, we unblock thread Y by handling the write protected page fault in Z. This first copies out R to userspace. But by doing this, it also frees R. So, we relinquish the above lock ensuring that Z continues. When Z continues, it will use setxattr with a value which if read will result in a page fault at the first byte. We catch this page fault in thread T but we don’t handle it, meaning R remains in place.

After we have R’s data, we locate the current R->sq_creds in our userspace buffer at offset 78 (with scale factor sizeof(uint64)). After reading the leaked sq_creds, we subtract 176 from it. The intention is to make R->sq_creds point “behind” the current cred object. We then write the new value back into our userspace buffer. Finally, we unblock thread X by handling the page fault issued from setxattr. This writes our userspace buffer to R, maintaining all fields except sq_creds which we have manipulated. But by doing this, we also free R. So we use setxattr again and catch it in H, in the same way as in T.

Fifth, from thread T we obtain a file descriptor for the directory “/etc/” using open() directly. Then we issue an openat request to the io_uring instance. After retrieving the completion queue entry, we have a file descriptor for “/etc/shadow”. Finally, we issue a read request which copies the contents of “/etc/shadow” into a userspace buffer. 
